---
title: 初级排序算法
date: 2019-09-19 14:50:35
updated: 2019-09-19 14:50:35
tags:
---

初级排序算法很简单,也很好理解,后面会有写算法基于简单的算法进行的改进.比如希尔基于插入.

和书中一样,用 js 写一个类,然后写作为比较的 less 方法,和交换数组元素的 exch 方法.

验证:
: 测试编写一个测试方法 isSorted 判断排序后的数组是否有序.

运行时间:
: 评估算法的性能.

额外的内存使用
: 额外的内存开销和运行时间同等重要.
: 除了函数调用所需的栈和固定数目的实例变量之外,无需额外内存的叫做 **原地排序算法**.
: 需要额外空间来存储另一份的数据副本的其他排序算法.

成本模型:
: 对于交换元素的算法计算比较和交换的数量、对于不交换元素的算法几算法访问数组的次数.

#### 选择排序

思想:
: 选择排序的思想很简单.
- 建立两个标示为一个代表需要交换的位置
- 一个代表当前数组子集的最小值
- 数组子集范围是当前需要交换位置到数组结束
  
每次在数组的子集中找最小的和当前的交换,如果数组中最小的是自己,就自己和自己交换,然后向后移动需要交换的位置缩小子集,当移动到最后一个位置的时候数组就有序了.

这种方法叫做 **选择排序** 的原因是因为它不断地选择剩余元素中的最小值

特点:
: **运行时间和输入无关.** 为了找出最小元素需要遍历一遍数组,输入有序无序都不影响这个操作,在一个有序中这个特点反而是个缺点
: **数据移动最少** 更多的操作是数据遍历

时间复杂度: N^2^
对于长度为 N 的数组. 需要大约 N^2^/2 次比较和 N 次交换.
也就是 ~ N^2^

空间复杂度: 1
: 这就是一个典型的原地排序算法没有用多余的数组空间

**实现**
```js selection sort
function selectionSort(arr){
  let N = arr.length
  for(let i = 0;i<N;i++){
    let min = i;
    for(let j = i+1;j<N;j++){
      if(less(arr[j],arr[min])){
        min = j
      }
    }
    exch(arr,i,min)
  }
}
```

#### 插入排序

当时我在研究这俩算法的时候差点买一扑克牌,这俩排序太像捋牌的过程.

思想:
:  一张一张的过牌,将每一张牌插入到已经有序牌中的适当位置.
: 一个标示位标示当前的这张牌
: 一个标示位标示适当的位置
: 一次循环就是一张一张的过牌,内循环就是把当前这张牌插入合适的位置.
实现中,为了要给插入的元素腾空间,我们要把其余的元素在插入之前右移.


特点:
: 和选择排序不同,插入排序所需的时间取决与输入元素的初始循序.对于有序的数组进行排序将会比对随机循序的数组或者逆序的数组要快的多. *这句话也是后面希尔排序产生的原因*

时间复杂度: N 和 N^2^ 之间
因为算法和输入相关所以就有最好和最坏的情况,在元素不重复的情况下
最好情况下需要 *N-1* 和 0 次交换
最坏情况下需要 ~ *N*^2^/2 次比较和 ~ *N*^2^/2 次交换
平均情况下需要 ~ *N*^2^/4 次比较和 ~ *N*^2^/4 次交换

**空间复杂度:** 1

插入排序的场景一般情况下是**部分有序**的数组

部分有序
: 数组中每个元素距离它最终的位置都不远 
: 一个有序的大数组接一个有序的小数组
: 数组中只有几个元素的位置不正确

插入排序对这样的数组很有效,事实上,当倒置的数量很少时,插入排序很可能比贲张的任何其他算法都快

**实现**
```js insertion sort
function insertionSort(arr){
  let N = arr.length;
  for(let i = 0;i<N;i++){
    // 内循环移动并交换大于arr[i]的元素
    for(let j = i;j>0 && less(arr[j],arr[j-1]);j--){
      exch(arr,j,j-1)
    }

  }
}
test("插入排序",insertionSort)
```

#### 希尔排序
希尔排序是插入排序的一种改进,插入排序在面对大规模乱序的数组的时候很慢,原因在于它只是交换相邻的元素,因此元素只能一点点的从数组中移动.
希尔排序的主要思想是构建**部分有序**数组,把数组变成插入排序想要的那种

思想:
初始化一个 h , h 代表一个**递增序列** 1 2 3 4 5 或者 1 3 5 6 12 等
实现希尔排序是对于每个 h ,用插入排序将 h 个子数组独立的排序,这样就构建了多个部分有序数组而且子数组很短

时间复杂度:
这个时间复杂度很迷茫,只是知道它突破了 平方级别的限制
书中写的复杂度是 NlogN? N^6/5^? 没看懂是啥意思
这个复杂度应该是取决于序列 h 

**实现**
```js shell sort
function shellSort(arr){
  let h = 1;
  let N = arr.length;
  while(h<N/3)h=3*h+1; // 1 4 13 40 121 ...
  while(h >= 1){
    for(let i = h;i<N;i++){
      for(let j = i;j>=h && less(arr[j],arr[j-h]);j-=h){
        exch(arr,j,j-h)
      } 
    }
    h = parseInt(h/3);
  }
}
test("希尔排序",shellSort)
```

#### 总结
这几种算法写了 N 遍我也没记住过应该怎么写,都是按照书里抄来的.